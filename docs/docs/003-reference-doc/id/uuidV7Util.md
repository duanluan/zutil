# UuidV7Util UUID v7 生成器

> 📦 **包路径**: `top.csaf.id.UuidV7Util`
>
> 🔗 **所属模块**: `zutil-all`

**UuidV7Util** 是一个高性能、无锁、线程安全的 **UUID Version 7** 生成器。
基于 **RFC 9562** 标准实现。相比于常见的 UUID v4（完全随机），UUID v7 是 **基于时间戳** 的，具有单调递增的特性，这使得它非常适合作为 **数据库主键**，能显著减少 B+ 树索引的页分裂，提升写入性能。

## ✨ 核心特性

* **高性能**: 采用 `ThreadLocal` 机制，每个线程独立维护状态，**无锁设计 (Lock-Free)**，在多线程高并发下性能极佳。
* **数据库友好**: 高 48 位为毫秒级时间戳，保证了 **大致的单调递增** 顺序，优化数据库索引写入。
* **时钟回拨处理**: 内部实现了简单的追赶机制，如果系统时钟回拨，生成器会保持序列号递增，确保 ID 不重复且保持单调性。
* **内存优化**: 提供了极速的 `simpleUUID()` 方法，将 UUID 转为 32 位 Hex 字符串的速度比 JDK 原生方式快 4-5 倍。

## 🚀 方法概览

| 方法名 | 描述 | 输出示例 |
| :--- | :--- | :--- |
| `randomUUID()` | 获取一个 `java.util.UUID` 对象 (v7) | `018e6b12-1c2d-7411-93d3-123456789abc` |
| `randomString()` | 获取标准格式字符串 (36位, 带横线) | `"018e6b12-1c2d-7411-93d3-123456789abc"` |
| `simpleUUID()` | 获取紧凑格式字符串 (32位, 无横线) | `"018e6b121c2d741193d3123456789abc"` |

## 📝 详细用法

### 1. 生成对象 (UUID)

获取标准的 Java UUID 对象，可用于需要该类型的接口。

```java
import java.util.UUID;
import top.csaf.id.UuidV7Util;

UUID uuid = UuidV7Util.randomUUID();
System.out.println("Version: " + uuid.version()); // 7
```

### 2. 生成标准字符串 (36位)

生成符合 UUID 标准格式的字符串（带连字符 `-`）。
> 注意：这里使用了 `randomString()` 而不是 `toString()`，避免与 Object 方法混淆。

```java
String token = UuidV7Util.randomString();
// -> "018e6b12-1c2d-7411-93d3-..."
```

### 3. 生成紧凑字符串 (32位)

常用于数据库存储（char(32)）或作为文件名。
此方法经过极致优化，性能远高于 `uuid.toString().replace("-", "")`。

```java
String dbId = UuidV7Util.simpleUUID();
// -> "018e6b121c2d741193d3..."
```

---

## ⚙️ 进阶说明

### 为什么选择 UUID v7？

| 特性 | UUID v4 (JDK 默认) | UUID v7 (本工具) |
| :--- | :--- | :--- |
| **生成方式** | 完全随机 | 时间戳 + 序列号 + 随机数 |
| **排序性** | 无序 | **按时间单调递增** |
| **数据库性能** | 差 (造成索引碎片) | **优 (顺序写入)** |
| **碰撞概率** | 极低 | 极低 |
| **包含时间信息**| 否 | 是 (精确到毫秒) |

### 并发实现原理

内部使用 `ThreadLocal<V7Generator>` 为每个线程分配独立的生成器实例。
* **无竞争**: 线程之间互不干扰，无需 `synchronized` 或 `CAS` 等待。
* **序列号管理**: 同一毫秒内，单线程通过递增序列号（12位）防止冲突；如果序列号耗尽，借用下一毫秒时间戳。
